<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Pushdemo by MEIZUPUSH</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Pushdemo</h1>
      <h2 class="project-tagline">魅族PushDemo Android端源码，方便开发者接入</h2>
      <a href="https://github.com/MEIZUPUSH/PushDemo" class="btn">View on GitHub</a>
      <a href="https://github.com/MEIZUPUSH/PushDemo/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/MEIZUPUSH/PushDemo/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="pushsdk31-说明文档" class="anchor" href="#pushsdk31-%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>PushSDK3.1 说明文档</h1>

<h1>
<a id="目录" class="anchor" href="#%E7%9B%AE%E5%BD%95" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>目录<a name="index"></a>
</h1>

<ul>
<li><a href="#app_backgroud">一.应用背景</a></li>
<li><a href="#design_thought">二.设计思想</a></li>
<li>
<p><a href="#integrete_setting_description">三.魅族云推送集成说明</a></p>

<ul>
<li><a href="#prepare_setting">准备工作</a></li>
<li><a href="#pushsdk_internal">3.1 pushSDK内部版引用配置说明</a></li>
<li><a href="#pushsdk_open">3.2 pushSDK外部版引用配置说明</a></li>
<li>
<a href="#nessary_setting">3.3 必要的配置</a>

<ul>
<li><a href="#permission_adpter_flyme5_down">3.3.1 兼容flyme5以下版本推送兼容配置</a></li>
<li><a href="#pushmessage_receiver_manifest_setting">3.3.2 注册消息接收Receiver</a></li>
<li><a href="#pushmessage_receiver_code_setting">3.3.3 实现自有的PushReceiver,实现消息接收，注册与反注册回调</a></li>
</ul>
</li>
<li>
<a href="#pushmanager_interface_describe">3.4 PushManager接口说明</a>

<ul>
<li><a href="#register_description"><del>3.4.1 旧版Push注册接口</del></a></li>
<li><a href="#unregister_description"><del>3.4.2 旧版Push反注册接口</del></a></li>
<li><a href="#register">3.4.3 订阅接口</a></li>
<li><a href="#unregister">3.4.4 反订阅接口</a></li>
<li><a href="#pushmessage_switcher">3.4.5 通知栏和透传消息开关状态转换</a></li>
<li><a href="#check_switcher">3.4.6 检查通知栏和透传消息开关状态</a></li>
<li><a href="#subscribe_tags">3.4.7 标签订阅</a></li>
<li><a href="#un_subscribe_tags">3.4.8 取消标签订阅</a></li>
<li><a href="#chekc_subscribe_tags">3.4.9 获取标签订阅列表</a></li>
<li><a href="#subscribe_alias">3.4.10 别名订阅</a></li>
<li><a href="#un_subscribe_alias">3.4.11 取消别名订阅</a></li>
<li><a href="#check_subscribe_alias">3.4.12 获取别名</a></li>
<li><a href="#get_push_id">3.4.13 获取pushId</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#notification_description">四 通知栏消息扩展功能使用说明</a></p>

<ul>
<li><a href="#open_mainactivity">4.1 打开应用的主界面并获取推送消息参数</a></li>
<li><a href="#open_any_activity">4.2 打开某个应用某个页面时，获取推送消息参数</a></li>
<li>
<a href="#parameter_setting">4.3 参数配置说明</a>

<ul>
<li><a href="#activity_name">4.3.1 页面名称</a></li>
<li><a href="#parameter_value">4.3.2 参数与值</a></li>
</ul>
</li>
<li><a href="#open_web">4.3 打开URI</a></li>
<li><a href="#set_notification_builder">4.4 自定义通知栏</a></li>
</ul>
</li>
<li><p><a href="#feedback">反馈与建议</a></p></li>
<li><a href="#question_and_answer">问题汇总说明</a></li>
</ul>

<h2>
<a id="概述" class="anchor" href="#%E6%A6%82%E8%BF%B0" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>概述</h2>

<p>如果你对pushSDK的实现原理感兴趣，请点击这里 <a href="http://comsince.github.io/push-design-thirdparty-doc">PushSDK第三方设计实践</a> ，另外这个工程也提供的源码，有兴趣的同学可以star一下！</p>

<h2>
<a id="一-应用背景" class="anchor" href="#%E4%B8%80-%E5%BA%94%E7%94%A8%E8%83%8C%E6%99%AF" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>一 应用背景<a name="app_backgroud"></a>
</h2>

<p>app为了及时获取到服务器端的消息更新，一般会采用轮寻或者推送的方式来获取消息更新，轮寻导致终端设备流量、电量、等系统资源严重浪费，所以目前采用的比较广泛的是推送的方式，目前 Meizu 的 Push SDK 不能脱离 Flyme OS 存在，当该 SDK 脱离 Flyme OS 之后由于没有长链接导致不能正常收到推送消息。本 SDK 首先要解决的时长链接由 SDK 自己维护，同时还要解决的就是多个 app 引用同一个 SDK 时长链接的复用问题。</p>

<h2>
<a id="二-设计思想" class="anchor" href="#%E4%BA%8C-%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>二 设计思想<a name="design_thought"></a>
</h2>

<p>该 SDK 以 Android Service 方式运行，独占一个进程，该 Service 自己维护与推送服务器的长链接。如果一款手机安装了多个集成了 SDK 的手机应用，则只有一个 service 实例运行，不会每个应用都会开启一个后台 service，而是采用多个应用共享一个Push通道的方式，这就解决了长链接复用的问题，节省了对流量、电量的浪费。使用该 SDK 只需要关心 PushManager 提供的API，与 MzPushMessageReceiver 提供的回调接口以及相应的配置即可。</p>

<h2>
<a id="三-魅族云推送集成说明" class="anchor" href="#%E4%B8%89-%E9%AD%85%E6%97%8F%E4%BA%91%E6%8E%A8%E9%80%81%E9%9B%86%E6%88%90%E8%AF%B4%E6%98%8E" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>三 魅族云推送集成说明<a name="integrete_setting_description"></a>
</h2>

<h3>
<a id="准备工作" class="anchor" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>准备工作<a name="prepare_setting"></a>
</h3>

<p>PushSDK3.0以后的版本使用了最新的魅族插件发布aar包，因此大家可以直接引用aar包；无需关心libs so库的配置，对于一些通用的权限配置，工程混淆，应用可以不再配置了，现有你只需要在你的应用中配置相应的消息接收的receiver</p>

<h3>
<a id="31-pushsdk内部版引用配置说明" class="anchor" href="#31-pushsdk%E5%86%85%E9%83%A8%E7%89%88%E5%BC%95%E7%94%A8%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.1 pushSDK内部版引用配置说明<a name="pushsdk_internal"></a>
</h3>

<p><strong>NOTE:</strong> 请按照项目需求选取用的引用方式引用aar包,第三方开放者需要自行下载pushSDK包,开发这除了要将依赖PushSDK里面的aar,还需配置如下公共开源库</p>

<ul>
<li>对内版本配置如下：</li>
</ul>

<pre><code>    dependencies {
        compile "com.android.support:support-v4:22.2.0"
        compile 'com.android.volley:volley:1.0.0'
        compile 'com.squareup.okhttp:okhttp:2.1.0'
    }
</code></pre>

<p><strong>NOTE:</strong> 以下内容只是说明push-internal的传递依赖关系,不需要重复配置,实际接入只需要配置上面的就行了</p>

<ul>
<li> 工程依赖关系
PushSDK内部版本aar包托管在meizu的artifactory上,其默认依赖以下库:

<ul>
<li>meizu内部库
现在Gslb,uxip已经由平台研发部接管，如果你用的旧版本，请以以下版本为准,不要在使用老版本了

<ul>
<li>MzGslb   <code>com.meizu.flyme.internet:gslb:3.0.8</code> 魅族GSLB组件</li>
<li>MzUxip   <code>com.meizu.flyme.internet:usage-stats:2.5.1</code> 数据统计组件</li>
</ul>
</li>
<li>第三方开源库

<ul>
<li>Volley <code>com.android.volley:volley:1.0.0</code>
</li>
<li>okHttp <code>com.squareup.okhttp:okhttp:2.1.0</code>
</li>
<li>support_v4 <code>com.android.support:support-v4:22.2.0</code> 支持兼容低版本扩展通知栏功能</li>
</ul>
</li>
</ul>
</li>
</ul>

<p><strong>NOTE:</strong> 以下内容说明混淆规则</p>

<ul>
<li> 混淆
Meizu插件以前是将proguard文件独立发布,因此proguard文件需要独立配置,现在我们已经将proguard打包进了aar中,具体详见<a href="http://google.github.io/android-gradle-dsl/current/com.android.build.gradle.internal.dsl.BuildType.html#com.android.build.gradle.internal.dsl.BuildType:consumerProguardFiles">consumerProguardFiles</a>,因此就不再需要单独配置proguard远程依赖了</li>
</ul>

<h3>
<a id="32-pushsdk外部版引用配置说明" class="anchor" href="#32-pushsdk%E5%A4%96%E9%83%A8%E7%89%88%E5%BC%95%E7%94%A8%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.2 pushSDK外部版引用配置说明<a name="pushsdk_open"></a>
</h3>

<p><strong>NOTE:</strong> 如果是魅族内部应用请跳过此配置,如果应用需要支持第三方推送的可以进行以下配置,对外版本的SDK主要是在第三方Android Rom中实现推送功能,其默依赖pushSDK内部版,目前暂未开放</p>

<h3>
<a id="33-必要的配置" class="anchor" href="#33-%E5%BF%85%E8%A6%81%E7%9A%84%E9%85%8D%E7%BD%AE" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.3 必要的配置<a name="nessary_setting"></a>
</h3>

<h3>
<a id="331-兼容flyme5以下版本推送兼容配置" class="anchor" href="#331-%E5%85%BC%E5%AE%B9flyme5%E4%BB%A5%E4%B8%8B%E7%89%88%E6%9C%AC%E6%8E%A8%E9%80%81%E5%85%BC%E5%AE%B9%E9%85%8D%E7%BD%AE" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.3.1 兼容flyme5以下版本推送兼容配置<a name="permission_adpter_flyme5_down"></a>
</h3>

<pre><code>    &lt;!-- 兼容flyme5.0以下版本，魅族内部集成pushSDK必填，不然无法收到消息--&gt;
    &lt;uses-permission android:name="com.meizu.flyme.push.permission.RECEIVE"&gt;&lt;/uses-permission&gt;
    &lt;permission android:name="包名.push.permission.MESSAGE" android:protectionLevel="signature"/&gt;
    &lt;uses-permission android:name="包名.push.permission.MESSAGE"&gt;&lt;/uses-permission&gt;

    &lt;!--  兼容flyme3.0配置权限--&gt;
    &lt;uses-permission android:name="com.meizu.c2dm.permission.RECEIVE" /&gt;
    &lt;permission android:name="你的包名.permission.C2D_MESSAGE"
                    android:protectionLevel="signature"&gt;&lt;/permission&gt;
    &lt;uses-permission android:name="你的包名.permission.C2D_MESSAGE"/&gt;

</code></pre>

<h4>
<a id="332-注册消息接收receiver" class="anchor" href="#332-%E6%B3%A8%E5%86%8C%E6%B6%88%E6%81%AF%E6%8E%A5%E6%94%B6receiver" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.3.2 注册消息接收Receiver<a name="pushmessage_receiver_manifest_setting"></a>
</h4>

<div class="highlight highlight-text-xml"><pre>    <span class="pl-c">&lt;!-- push应用定义消息receiver声明 --&gt;</span>
    &lt;<span class="pl-ent">receiver</span> <span class="pl-e">android</span><span class="pl-e">:</span><span class="pl-e">name</span>=<span class="pl-s"><span class="pl-pds">"</span>your.package.MyPushMsgReceiver<span class="pl-pds">"</span></span>&gt;
        &lt;<span class="pl-ent">intent-filter</span>&gt;
            <span class="pl-c">&lt;!-- 接收push消息 --&gt;</span>
            &lt;<span class="pl-ent">action</span> <span class="pl-e">android</span><span class="pl-e">:</span><span class="pl-e">name</span>=<span class="pl-s"><span class="pl-pds">"</span>com.meizu.flyme.push.intent.MESSAGE<span class="pl-pds">"</span></span> /&gt;
            <span class="pl-c">&lt;!-- 接收register消息 --&gt;</span>
            &lt;<span class="pl-ent">action</span> <span class="pl-e">android</span><span class="pl-e">:</span><span class="pl-e">name</span>=<span class="pl-s"><span class="pl-pds">"</span>com.meizu.flyme.push.intent.REGISTER.FEEDBACK<span class="pl-pds">"</span></span> /&gt;
            <span class="pl-c">&lt;!-- 接收unregister消息--&gt;</span>
            &lt;<span class="pl-ent">action</span> <span class="pl-e">android</span><span class="pl-e">:</span><span class="pl-e">name</span>=<span class="pl-s"><span class="pl-pds">"</span>com.meizu.flyme.push.intent.UNREGISTER.FEEDBACK<span class="pl-pds">"</span></span>/&gt;
            <span class="pl-c">&lt;!-- 兼容低版本Flyme3推送服务配置 --&gt;</span>
            &lt;<span class="pl-ent">action</span> <span class="pl-e">android</span><span class="pl-e">:</span><span class="pl-e">name</span>=<span class="pl-s"><span class="pl-pds">"</span>com.meizu.c2dm.intent.REGISTRATION<span class="pl-pds">"</span></span> /&gt;
            &lt;<span class="pl-ent">action</span> <span class="pl-e">android</span><span class="pl-e">:</span><span class="pl-e">name</span>=<span class="pl-s"><span class="pl-pds">"</span>com.meizu.c2dm.intent.RECEIVE<span class="pl-pds">"</span></span> /&gt;
            &lt;<span class="pl-ent">category</span> <span class="pl-e">android</span><span class="pl-e">:</span><span class="pl-e">name</span>=<span class="pl-s"><span class="pl-pds">"</span>包名<span class="pl-pds">"</span></span>&gt;&lt;/<span class="pl-ent">category</span>&gt;
        &lt;/<span class="pl-ent">intent-filter</span>&gt;
    &lt;/<span class="pl-ent">receiver</span>&gt;</pre></div>

<h4>
<a id="333-实现自有的pushreceiver实现消息接收注册与反注册回调" class="anchor" href="#333-%E5%AE%9E%E7%8E%B0%E8%87%AA%E6%9C%89%E7%9A%84pushreceiver%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E6%8E%A5%E6%94%B6%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%8D%E6%B3%A8%E5%86%8C%E5%9B%9E%E8%B0%83" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.3.3 实现自有的PushReceiver,实现消息接收，注册与反注册回调<a name="pushmessage_receiver_code_setting"></a>
</h4>

<pre><code>    public class MyPushMsgReceiver extends MzPushMessageReceiver {

            @Override
            @Deprecated
            public void onRegister(Context context, String pushid) {
               //应用在接受返回的pushid
            }

            @Override
            public void onMessage(Context context, String s) {
            //接收服务器推送的消息
            }

            @Override
            @Deprecated
            public void onUnRegister(Context context, boolean b) {
            //调用PushManager.unRegister(context）方法后，会在此回调反注册状态
            }

            //设置通知栏小图标
            @Override
            public PushNotificationBuilder onUpdateNotificationBuilder(PushNotificationBuilder pushNotificationBuilder) {
            pushNotificationBuilder.setmStatusbarIcon(R.drawable.mz_stat_share_weibo);
            }

            @Override
            public void onPushStatus(Context context,PushSwitchStatus pushSwitchStatus) {
            //检查通知栏和透传消息开关状态回调
            }

            @Override
            public void onRegisterStatus(Context context,RegisterStatus registerStatus) {
               Log.i(TAG, "onRegisterStatus " + registerStatus);
                    //新版订阅回调
            }

            @Override
            public void onUnRegisterStatus(Context context,UnRegisterStatus unRegisterStatus) {
              Log.i(TAG,"onUnRegisterStatus "+unRegisterStatus);
                    //新版反订阅回调
            }

            @Override
            public void onSubTagsStatus(Context context,SubTagsStatus subTagsStatus) {
               Log.i(TAG, "onSubTagsStatus " + subTagsStatus);
            //标签回调
            }

            @Override
            public void onSubAliasStatus(Context context,SubAliasStatus subAliasStatus) {
               Log.i(TAG, "onSubAliasStatus " + subAliasStatus);
                    //别名回调
            }
            @Override
            public void onNotificationArrived(Context context, String title, String content, String selfDefineContentString) {
                DebugLogger.i(TAG,"onNotificationArrived title "+title + "content "+content + " selfDefineContentString "+selfDefineContentString);
            }

            @Override
            public void onNotificationClicked(Context context, String title, String content, String selfDefineContentString) {
                DebugLogger.i(TAG,"onNotificationClicked title "+title + "content "+content + " selfDefineContentString "+selfDefineContentString);
            }

            @Override
            public void onNotificationDeleted(Context context, String title, String content, String selfDefineContentString) {
                DebugLogger.i(TAG,"onNotificationDeleted title "+title + "content "+content + " selfDefineContentString "+selfDefineContentString);
            }    

        }
</code></pre>

<p><strong>Note:</strong> 至此pushSDK 已经集成完毕，现在你需要在你的Application中调用新版的<a href="#register">register</a>方法,并在你的Receiver中成功回调onRegisterStatus(RegisterStatus registerStatus)方法就可以了，
你现在可以到<a href="http://push.meizu.com">新版Push平台</a> 找到你的应用推送消息就可以了;以下内容是pushSDK提供的api汇总,具体功能详见api具体说明,请根据需求选用合适的功能</p>

<h3>
<a id="34-pushmanager接口说明" class="anchor" href="#34-pushmanager%E6%8E%A5%E5%8F%A3%E8%AF%B4%E6%98%8E" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.4 PushManager接口说明<a name="pushmanager_interface_describe"></a>
</h3>

<h4>
<a id="341-旧版订阅接口" class="anchor" href="#341-%E6%97%A7%E7%89%88%E8%AE%A2%E9%98%85%E6%8E%A5%E5%8F%A3" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.4.1 <del>旧版订阅接口</del><a name="register_description"></a>
</h4>

<pre><code>    /**
      * 订阅接口
      */
    public static void register(Context context);
</code></pre>

<p><strong>NOTE:</strong> 此接口已经废弃建议使用新版的订阅接口</p>

<ul>
<li>说明：原则上应用调用register方法表示与服务器建立推送关系，这是可以通过push平台向该应用推送消息了，所以应用至少要调用过一次register方法,应用为了防止多次重复注册，可以先判断一下是否获取成功过pushid，具体实现代码如下：</li>
</ul>

<div class="highlight highlight-source-java"><pre>    <span class="pl-k">if</span>(<span class="pl-smi">PushManager</span><span class="pl-k">.</span>getPushId(context) <span class="pl-k">==</span> <span class="pl-c1">null</span>){
       <span class="pl-smi">PushManager</span><span class="pl-k">.</span>register(<span class="pl-smi">Context</span> context)
    }
</pre></div>

<p><strong>Note:</strong></p>

<ul>
<li>(1)如果应用需要取消订阅,调用如下方法 PushManager.unRegister(Context context)</li>
<li>(2)应用如果成功获取到pushId,可以调用一下方法获取本应用的pushId PushManager.getPushId(Context context)</li>
</ul>

<h4>
<a id="342-旧版反订阅接口" class="anchor" href="#342-%E6%97%A7%E7%89%88%E5%8F%8D%E8%AE%A2%E9%98%85%E6%8E%A5%E5%8F%A3" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.4.2 <del>旧版反订阅接口</del><a name="unregister_description"></a>
</h4>

<p><strong>NOTE:</strong> 此接口已经废弃</p>

<pre><code>    /**
      * 反订阅
      * */
    public static void unRegister(Context context);
</code></pre>

<p><strong>NOTE:</strong> 以下为新版的接口,所有的接口对应的回调都你的配置的PushReceiver中</p>

<h4>
<a id="343-订阅接口" class="anchor" href="#343-%E8%AE%A2%E9%98%85%E6%8E%A5%E5%8F%A3" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.4.3 订阅接口<a name="register"></a>
</h4>

<ul>
<li>接口说明</li>
</ul>

<pre><code>   /**
     * @param context
     * @param appId
     *         push 平台申请的应用id
     * @param appKey
     *         push 平台申请的应用key
     * */
     public static void register(Context context,String appId,String appKey);
</code></pre>

<ul>
<li>对应Receiver中的回调方法</li>
</ul>

<pre><code>    @Override
    public void onRegisterStatus(Context context,RegisterStatus registerStatus) {

    }
</code></pre>

<h4>
<a id="344-反订阅接口" class="anchor" href="#344-%E5%8F%8D%E8%AE%A2%E9%98%85%E6%8E%A5%E5%8F%A3" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.4.4 反订阅接口<a name="unregister"></a>
</h4>

<ul>
<li>接口说明</li>
</ul>

<pre><code>   /**
     * @param context
     * @param appId
     *         push 平台申请的应用id
     * @param appKey
     *         push 平台申请的应用key
     * */
     public static void unRegister(Context context,String appId,String appKey);
</code></pre>

<ul>
<li>对应Receiver中的回调方法</li>
</ul>

<pre><code>    @Override
    public void onUnRegisterStatus(Context context,UnRegisterStatus unRegisterStatus) {

    }
</code></pre>

<h4>
<a id="345-通知栏和透传消息开关状态转换" class="anchor" href="#345-%E9%80%9A%E7%9F%A5%E6%A0%8F%E5%92%8C%E9%80%8F%E4%BC%A0%E6%B6%88%E6%81%AF%E5%BC%80%E5%85%B3%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.4.5 通知栏和透传消息开关状态转换<a name="pushmessage_switcher"></a>
</h4>

<ul>
<li>接口说明</li>
</ul>

<pre><code>   /**
     * @param appId
     *        push 平台申请的应用id
     * @param appKey
     *        push 平台申请的应用key
     * @param pushId
     *        注册成功后返回的pushid
     * @param pushType
     *        接收的消息类型，0:通知栏消息 1: 透传消息
     * @param switcher
     *        修改push类型开关状态
     * */
    public static void switchPush(Context context,String appId,String appKey,String pushId,int pushType,boolean switcher);
</code></pre>

<ul>
<li>对应Receiver中的回调方法</li>
</ul>

<pre><code>    @Override
    public void onPushStatus(Context context,PushSwitchStatus pushSwitchStatus) {

    }
</code></pre>

<h4>
<a id="346-检查通知栏和透传消息开关状态" class="anchor" href="#346-%E6%A3%80%E6%9F%A5%E9%80%9A%E7%9F%A5%E6%A0%8F%E5%92%8C%E9%80%8F%E4%BC%A0%E6%B6%88%E6%81%AF%E5%BC%80%E5%85%B3%E7%8A%B6%E6%80%81" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.4.6 检查通知栏和透传消息开关状态<a name="check_switcher"></a>
</h4>

<ul>
<li>接口说明</li>
</ul>

<pre><code>   /**
     * 检查通知栏和透传消息开关状态
     * @param appId
     *          push 平台申请的应用id
     * @param appKey
     *          push 平台申请的应用key
     * @param pushId
     *          注册成功后返回的pushid
     *
     *  结果会在你所实现的receiver的onCheckPush中返回
     * */
    public static void checkPush(Context context,String appId,String appKey,String pushId);
</code></pre>

<ul>
<li>对应Receiver中的回调方法</li>
</ul>

<pre><code>    @Override
    public void onPushStatus(Context context,PushSwitchStatus pushSwitchStatus) {

    }
</code></pre>

<h4>
<a id="347-标签订阅" class="anchor" href="#347-%E6%A0%87%E7%AD%BE%E8%AE%A2%E9%98%85" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.4.7 标签订阅<a name="subscribe_tags"></a>
</h4>

<ul>
<li>接口说明</li>
</ul>

<pre><code>   /**
     * 标签订阅
     * @param context
     * @param appId
     *         push 平台申请的应用id
     * @param appKey
     *         push 平台申请的应用key
     * @param tags
     *         多个标签逗号隔离
     * */
     public static void subScribeTags(Context context,String appId,String appKey,String pushId,String tags);
</code></pre>

<ul>
<li>对应Receiver中的回调方法</li>
</ul>

<pre><code>      @Override
      public void onSubTagsStatus(Context context,SubTagsStatus subTagsStatus) {
        Log.i(TAG, "onSubTagsStatus " + subTagsStatus);
        //标签回调
      }
</code></pre>

<h4>
<a id="348-取消标签订阅" class="anchor" href="#348-%E5%8F%96%E6%B6%88%E6%A0%87%E7%AD%BE%E8%AE%A2%E9%98%85" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.4.8 取消标签订阅<a name="un_subscribe_tags"></a>
</h4>

<ul>
<li>接口说明</li>
</ul>

<pre><code>    /**
      * 取消标签订阅
      * @param context
      * @param appId
      *         push 平台申请的应用id
      * @param appKey
      *         push 平台申请的应用key
      * @param tags
      *         多个标签逗号隔离
      * */
     public static void unSubScribeTags(Context context, String appId, String appKey, String pushId,String tags);
</code></pre>

<ul>
<li>对应Receiver中的回调方法</li>
</ul>

<pre><code>      @Override
      public void onSubTagsStatus(Context context,SubTagsStatus subTagsStatus) {
        Log.i(TAG, "onSubTagsStatus " + subTagsStatus);
        //标签回调
      }
</code></pre>

<h4>
<a id="349-获取标签订阅列表" class="anchor" href="#349-%E8%8E%B7%E5%8F%96%E6%A0%87%E7%AD%BE%E8%AE%A2%E9%98%85%E5%88%97%E8%A1%A8" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.4.9 获取标签订阅列表<a name="chekc_subscribe_tags"></a>
</h4>

<ul>
<li>接口说明</li>
</ul>

<pre><code>   /**
     * 获取标签订阅列表
     * @param context
     * @param appId
     *         push 平台申请的应用id
     * @param appKey
     *         push 平台申请的应用key
     * */
     public static void checkSubScribeTags(Context context,String appId,String appKey,String pushId);
</code></pre>

<ul>
<li>对应Receiver中的回调方法</li>
</ul>

<pre><code>      @Override
      public void onSubTagsStatus(Context context,SubTagsStatus subTagsStatus) {
        Log.i(TAG, "onSubTagsStatus " + subTagsStatus);
        //标签回调
      }
</code></pre>

<h4>
<a id="3410-别名订阅" class="anchor" href="#3410-%E5%88%AB%E5%90%8D%E8%AE%A2%E9%98%85" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.4.10 别名订阅<a name="subscribe_alias"></a>
</h4>

<ul>
<li>接口说明</li>
</ul>

<pre><code>   /**
     * 别名订阅
     * @param context
     * @param appId
     *         push 平台申请的应用id
     * @param appKey
     *         push 平台申请的应用key
     * @param pushId
     *         注册成功后返回的pushid
     * @param alias
     *         别名
     * */
     public static void subScribeAlias(Context context,String appId,String appKey,String pushId,String alias);
</code></pre>

<ul>
<li>对应Receiver中的回调方法</li>
</ul>

<pre><code>    @Override
    public void onSubAliasStatus(Context context,SubAliasStatus subAliasStatus) {
        Log.i(TAG, "onSubAliasStatus " + subAliasStatus);
    }
</code></pre>

<h4>
<a id="3411-取消别名订阅" class="anchor" href="#3411-%E5%8F%96%E6%B6%88%E5%88%AB%E5%90%8D%E8%AE%A2%E9%98%85" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.4.11 取消别名订阅<a name="un_subscribe_alias"></a>
</h4>

<ul>
<li>接口说明</li>
</ul>

<pre><code>   /**
     * 取消别名订阅
     * @param context
     * @param appId
     *         push 平台申请的应用id
     * @param appKey
     *         push 平台申请的应用key
     * @param pushId
     *         注册成功后返回的pushid
     * @param alias
     *         别名
     * */
     public static void unSubScribeAlias(Context context,String appId,String appKey,String pushId,String alias);
</code></pre>

<ul>
<li>对应Receiver中的回调方法</li>
</ul>

<pre><code>    @Override
    public void onSubAliasStatus(Context context,SubAliasStatus subAliasStatus) {
        Log.i(TAG, "onSubAliasStatus " + subAliasStatus);
    }
</code></pre>

<h4>
<a id="3412-获取别名" class="anchor" href="#3412-%E8%8E%B7%E5%8F%96%E5%88%AB%E5%90%8D" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.4.12 获取别名<a name="check_subscribe_alias"></a>
</h4>

<ul>
<li>接口说明</li>
</ul>

<pre><code>   /**
     * 获取别名
     * @param context
     * @param appId
     *         push 平台申请的应用id
     * @param appKey
     *         push 平台申请的应用key
     * @param pushId
     *         注册成功后返回的pushid
     * */
     public static void checkSubScribeAlias(Context context,String appId,String appKey,String pushId)
</code></pre>

<ul>
<li>对应Receiver中的回调方法</li>
</ul>

<pre><code>    @Override
    public void onSubAliasStatus(Context context,SubAliasStatus subAliasStatus) {
        Log.i(TAG, "onSubAliasStatus " + subAliasStatus);
    }
</code></pre>

<h4>
<a id="3413-获取pushid" class="anchor" href="#3413-%E8%8E%B7%E5%8F%96pushid" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.4.13 获取pushId<a name="get_push_id"></a>
</h4>

<ul>
<li>接口说明</li>
</ul>

<pre><code>   /**
     * 根据应用包名获取pushId
     * @param context
     * @return 如果该包名没有注册，则默认返回为null
     * */
    public static String getPushId(Context context);
</code></pre>

<h2>
<a id="四-通知栏消息扩展功能使用说明" class="anchor" href="#%E5%9B%9B-%E9%80%9A%E7%9F%A5%E6%A0%8F%E6%B6%88%E6%81%AF%E6%89%A9%E5%B1%95%E5%8A%9F%E8%83%BD%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>四 通知栏消息扩展功能使用说明<a name="notification_description"></a>
</h2>

<h3>
<a id="41-打开应用的主界面并获取推送消息参数" class="anchor" href="#41-%E6%89%93%E5%BC%80%E5%BA%94%E7%94%A8%E7%9A%84%E4%B8%BB%E7%95%8C%E9%9D%A2%E5%B9%B6%E8%8E%B7%E5%8F%96%E6%8E%A8%E9%80%81%E6%B6%88%E6%81%AF%E5%8F%82%E6%95%B0" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>4.1 打开应用的主界面并获取推送消息参数<a name="open_mainactivity"></a>
</h3>

<p>在push平台选择打开应用主界面，推送完消息后，手机端收到通知栏消息，应用点击通知栏会跳转到应用的主界面 ，此时你在push平台配置的参数与值将通过intent传递给你，你可以通过以下代码获取值</p>

<pre><code> String value = getIntent().getStringExtra("key")
 通过在push平台上配置的参数，获取其value值,这里的key值就是你在push平台上配置的键值
</code></pre>

<h3>
<a id="42-打开某个应用某个页面时获取推送消息参数" class="anchor" href="#42-%E6%89%93%E5%BC%80%E6%9F%90%E4%B8%AA%E5%BA%94%E7%94%A8%E6%9F%90%E4%B8%AA%E9%A1%B5%E9%9D%A2%E6%97%B6%E8%8E%B7%E5%8F%96%E6%8E%A8%E9%80%81%E6%B6%88%E6%81%AF%E5%8F%82%E6%95%B0" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>4.2 打开某个应用某个页面时，获取推送消息参数<a name="open_any_activity"></a>
</h3>

<p>打开应用某个页面，实际通过你在push平台配置的页面名称，参数key-value组建intent的方式传递给应用
如下是通过应用包名+activity名称+参数组建Intent的部分代码：</p>

<pre><code>  String intentUri = "intent:#Intent;component="+应用包名+"/"+AndroidManifest配置activity的名称+(TextUtils.isEmpty(key) ? ";" : ";"+Value)+"end";
  try {
     intent = Intent.parseUri(intentUri,Intent.URI_INTENT_SCHEME);
  } catch (URISyntaxException e) {
     e.printStackTrace();
  }
</code></pre>

<h3>
<a id="43参数配置说明" class="anchor" href="#43%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>4.3参数配置说明<a name="parameter_setting"></a>
</h3>

<h4>
<a id="431-页面名称" class="anchor" href="#431-%E9%A1%B5%E9%9D%A2%E5%90%8D%E7%A7%B0" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>4.3.1 页面名称<a name="activity_name"></a>
</h4>

<p>Push平台中页面名称实际为：应用要打开的Activity名称,即是相对应用的包名的Activity名称，如下一段配置</p>

<pre><code>&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="你的包名"&gt;
    &lt;application
        android:allowBackup="true"
        android:icon="@drawable/ic_launcher"
        android:label="@string/app_name"
        android:theme="@style/AppTheme" &gt;
        &lt;activity android:name=".TestAcitivity"&gt;
        &lt;/activity&gt;
    &lt;/application&gt;
 &lt;/manifest&gt;
</code></pre>

<p>比如你要打开应用下面的TestActivity这个页面，Push平台页面这个选项就填写.TestAcitivity,pushSDK就会根据这个名称组建该页面的完整路径：应用包名.TestAcitivity;这样当你点击通知栏时就会打开你配置的页面了。</p>

<blockquote>
<p><strong>Note:</strong> 更为简洁的做法是将该activity的全路径全部写出来如下：（com.meizu.cloud.setting.loginAcitivity）</p>
</blockquote>

<h4>
<a id="432-参数与值" class="anchor" href="#432-%E5%8F%82%E6%95%B0%E4%B8%8E%E5%80%BC" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>4.3.2 参数与值<a name="parameter_value"></a>
</h4>

<p>在push平台上配置的参数，是以key-value的方式传递给pushSDK,当pushSDK收到通知后会组建参数通过Intent传递给应用的相关界面, 应用可通过下面的方法逐一获取相应的value值</p>

<pre><code>String value = getIntent().getStringExtra("push平台配置的键值")
通过在push平台上配置的参数，获取其value值,这里的key值就是你在push平台上配置的键值
</code></pre>

<h3>
<a id="43-打开网页" class="anchor" href="#43-%E6%89%93%E5%BC%80%E7%BD%91%E9%A1%B5" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>4.3 打开网页<a name="open_web"></a>
</h3>

<p>当你push平台选取了打开网页这个选项，并配置的网页地址，当pushSDK收到消息后就会弹出通知栏，当你点击后会跳转到你设置的默认的浏览器显示当前的网页</p>

<h3>
<a id="44-自定义通知栏" class="anchor" href="#44-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%80%9A%E7%9F%A5%E6%A0%8F" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>4.4 自定义通知栏<a name="set_notification_builder"></a>
</h3>

<p>PushSDK加入了通知栏状态栏小图标自定义的功能，需要在配置的的pushReceiver中覆盖如下的方法：</p>

<pre><code>    /**
     * 获取smallicon
     * */
    public void onUpdateNotificationBuilder(PushNotificationBuilder pushNotificationBuilder){
          //设置通知栏弹出的小图标
          pushNotificationBuilder.setmStatusbarIcon(R.drawalbe.icon);
    };
</code></pre>

<blockquote>
<p><strong>Note:</strong> 通知栏相关操作API都封装在PushNotificationBuilder 中，更多功能参见此类中的方法</p>
</blockquote>

<h2>
<a id="五-兼容flyme低版本推送" class="anchor" href="#%E4%BA%94-%E5%85%BC%E5%AE%B9flyme%E4%BD%8E%E7%89%88%E6%9C%AC%E6%8E%A8%E9%80%81" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>五 兼容Flyme低版本推送</h2>

<h3>
<a id="51兼容说明" class="anchor" href="#51%E5%85%BC%E5%AE%B9%E8%AF%B4%E6%98%8E" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>5.1兼容说明</h3>

<p>云服务经历几次大的变更，从之前的C2DM，到现在可以完全脱离Flyme平台作为一种完全开放给第三方应用的SDK，在这个阶段出现多种集成方式，给以后的应用集成带来极大的困扰，魅族PushSDK极力在减少Flyme版本迭代给应用集成带来的麻烦，但应用还是需要做细小的更改才能做到与低版本Flyme的兼容。</p>

<h3>
<a id="52-兼容flyme30等低版本推送服务" class="anchor" href="#52-%E5%85%BC%E5%AE%B9flyme30%E7%AD%89%E4%BD%8E%E7%89%88%E6%9C%AC%E6%8E%A8%E9%80%81%E6%9C%8D%E5%8A%A1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>5.2 兼容Flyme3.0等低版本推送服务</h3>

<h4>
<a id="521-增加权限声明配置" class="anchor" href="#521-%E5%A2%9E%E5%8A%A0%E6%9D%83%E9%99%90%E5%A3%B0%E6%98%8E%E9%85%8D%E7%BD%AE" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>5.2.1 增加权限声明配置</h4>

<pre><code> &lt;uses-permission android:name="com.meizu.c2dm.permission.RECEIVE" /&gt;
 &lt;permission android:name="你的应用包名.permission.C2D_MESSAGE"
             android:protectionLevel="signature"&gt;&lt;/permission&gt;
 &lt;uses-permission android:name="你的应用包名.permission.C2D_MESSAGE"/&gt;
</code></pre>

<h4>
<a id="522-增加pushreceiver-action声明" class="anchor" href="#522-%E5%A2%9E%E5%8A%A0pushreceiver-action%E5%A3%B0%E6%98%8E" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>5.2.2 增加PushReceiver Action声明</h4>

<pre><code>  &lt;action android:name="com.meizu.c2dm.intent.REGISTRATION" /&gt;
  &lt;action android:name="com.meizu.c2dm.intent.RECEIVE" /&gt;
</code></pre>

<p>一个完整的兼容Flyme3.0 推送的Receiver配置如下:</p>

<pre><code>&lt;!-- push应用定义消息receiver声明 --&gt;
&lt;receiver android:name="your.package.PushMsgReceiver"&gt;
     &lt;intent-filter&gt;
     &lt;!-- 接收push消息 --&gt;
     &lt;action android:name="com.meizu.flyme.push.intent.MESSAGE" /&gt;
     &lt;!-- 接收register消息--&gt;
     &lt;action android:name="com.meizu.flyme.push.intent.REGISTER.FEEDBACK"/&gt;
     &lt;!-- 接收unregister消息--&gt;
     &lt;action android:name="com.meizu.flyme.push.intent.UNREGISTER.FEEDBACK"/&gt;
     &lt;!-- 兼容低版本Flyme推送服务配置 --&gt;
     &lt;action android:name="com.meizu.c2dm.intent.REGISTRATION" /&gt;
     &lt;action android:name="com.meizu.c2dm.intent.RECEIVE" /&gt;
     &lt;category android:name="你的应用包名"&gt;&lt;/category&gt;
     &lt;/intent-filter&gt;
 &lt;/receiver&gt;
</code></pre>

<h4>
<a id="523-实现onmessage接收推送消息" class="anchor" href="#523-%E5%AE%9E%E7%8E%B0onmessage%E6%8E%A5%E6%94%B6%E6%8E%A8%E9%80%81%E6%B6%88%E6%81%AF" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>5.2.3 实现onMessage接收推送消息</h4>

<p>PushMessageReceiver覆盖onMessage(Context context,Intent intent)方法接收Flyme3.0平台push消息</p>

<p>详情参见下面的方法的说明:</p>

<pre><code> /**
   * 收到推送消息的回调,Flyme4.0以上版本,或者云服务5.0以上版本 通过此方法接收Push消息
   * @param context
   *            context
   * @param message
   *            收到的推送消息
   * */
   public abstract void onMessage(Context context,String message);

   /**
   * 处理flyme3.0等以下平台的推送消息
   * @param context
   * @param intent
   *           flyme3.0平台上默认是将透传的消息json,按照key-value的组合设置到intent中,如果要获取相应的数据,可以调用intent.getExtra(key)方法获取
   * */
   public void onMessage(Context context,Intent intent){}
</code></pre>

<h4>
<a id="524-消息接入流程" class="anchor" href="#524-%E6%B6%88%E6%81%AF%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>5.2.4 消息接入流程</h4>

<p>注意这里的onMessage方法参数不一样,应用接收到消息后，需要自己从Intent中自行获取推送的消息,完整的流程如下</p>

<ul>
<li>(1) 调用Push接口接口发送消息时,消息体为一个正确Json字符串，例如：</li>
</ul>

<pre><code>{
       "content": "今日头像下载app狂送100元",
       "title": "今日头条重大利好",
       "isDiscard": true,
       "clickType": "1"
 }
</code></pre>

<ul>
<li>(2) 处理推送消息
例如应用需要获取content字段的内容,可以通过intent获取相应的内容，完成代码如下</li>
</ul>

<pre><code>    @Override
    public void onMessage(Context context, Intent intent) {
       String content = intent.getStringExtra("content");
       Log.i(TAG,"flyme3 onMessage "+content);
    }
</code></pre>

<h3>
<a id="反馈与建议" class="anchor" href="#%E5%8F%8D%E9%A6%88%E4%B8%8E%E5%BB%BA%E8%AE%AE" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>反馈与建议</h3>

<h3>
<a id="问题汇总说明" class="anchor" href="#%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%E8%AF%B4%E6%98%8E" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>问题汇总说明</h3>

<ul>
<li> 1.Push服务收到推送消息，但是应用不弹出通知栏
应用如果正确接入PushSDK，且能收到pushID表明Push服务与应用连接正常，有可能是应用没有配置混淆，导致MzPushSDK被混淆，无法正确解析消息所致</li>
</ul>

<h4>
<a id="一-配置类问题" class="anchor" href="#%E4%B8%80-%E9%85%8D%E7%BD%AE%E7%B1%BB%E9%97%AE%E9%A2%98" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>一. 配置类问题</h4>

<ul>
<li>现象</li>
</ul>

<pre><code>    android.content.ActivityNotFoundException: Unable to find explicit activity class
    {com.meizu.mzbbs/com.meizu.mzbbs.ui.DetailsActivity }; 
    have you declared this activity in your AndroidManifest.xml?
</code></pre>

<ul>
<li>原因
平台配置出现空格等特殊字符
activity配置出错</li>
</ul>

<h4>
<a id="二-网络问题" class="anchor" href="#%E4%BA%8C-%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>二. 网络问题</h4>

<ul>
<li>现象
接收不到推送</li>
<li>解决方案
请先确认你所连接的网络是外网还是内网，你可以清除云服务的数据，重新发起注册</li>
</ul>

<h4>
<a id="三-魅族手机未发布问题" class="anchor" href="#%E4%B8%89-%E9%AD%85%E6%97%8F%E6%89%8B%E6%9C%BA%E6%9C%AA%E5%8F%91%E5%B8%83%E9%97%AE%E9%A2%98" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>三 魅族手机未发布问题</h4>

<ul>
<li>现象
注册成功，收不到推送</li>
<li><p>原因分析
未发布的手机由于Brand字段不为meizu，导致注册的时候push任务手机为第三方手机，其采用的就是imei_sn的方式注册，返回的pushID即为imei_sn_appID</p></li>
<li><p>解决方案
等待发布Brand更改为魅族，或者直接使用imei_sn的推送方式</p></li>
</ul>

<h4>
<a id="四-日志分析" class="anchor" href="#%E5%9B%9B-%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>四 日志分析</h4>

<ul>
<li>日志地址</li>
</ul>

<pre><code>/sdcard/Android/data/pushSdk
</code></pre>

<h4>
<a id="五-aar引用问题" class="anchor" href="#%E4%BA%94-aar%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>五 aar引用问题</h4>

<ul>
<li>出现aar最新包不生效，删除gradle cache即可</li>
</ul>

<pre><code>    删除volley-gslb兼容包aar本地缓存，其他请求可自行选择目录删除
    rm -rf ~/.gradle/caches/modules-2/files-2.1/com.meizu.gslb.volley
</code></pre>

<h4>
<a id="六-push服务收到推送但是应用无法收到消息" class="anchor" href="#%E5%85%AD-push%E6%9C%8D%E5%8A%A1%E6%94%B6%E5%88%B0%E6%8E%A8%E9%80%81%E4%BD%86%E6%98%AF%E5%BA%94%E7%94%A8%E6%97%A0%E6%B3%95%E6%94%B6%E5%88%B0%E6%B6%88%E6%81%AF" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>六 push服务收到推送但是应用无法收到消息</h4>

<ul>
<li>现象
在熄屏状态下应用无法收到通知栏消息，亮屏时能收到通知栏消息,最新的flyme固件不会出现该问题</li>
<li>原因
系统问题，熄屏状态下发起服务调用，应用无响应,最新的flyme固件不会出现该问题</li>
</ul>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/MEIZUPUSH/PushDemo">Pushdemo</a> is maintained by <a href="https://github.com/MEIZUPUSH">MEIZUPUSH</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
