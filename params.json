{
  "name": "Pushdemo",
  "tagline": "魅族PushDemo Android端源码，方便开发者接入",
  "body": "# PushSDK3.1 说明文档\r\n\r\n\r\n# 目录<a name=\"index\"/>\r\n* [一.应用背景](#app_backgroud)\r\n* [二.设计思想](#design_thought)\r\n* [三.魅族云推送集成说明](#integrete_setting_description)\r\n    * [准备工作](#prepare_setting)\r\n    * [3.1 pushSDK内部版引用配置说明](#pushsdk_internal)\r\n    * [3.2 pushSDK外部版引用配置说明](#pushsdk_open)\r\n    * [3.3 必要的配置](#nessary_setting)\r\n        * [3.3.1 兼容flyme5以下版本推送兼容配置](#permission_adpter_flyme5_down)\r\n        * [3.3.2 注册消息接收Receiver](#pushmessage_receiver_manifest_setting)\r\n        * [3.3.3 实现自有的PushReceiver,实现消息接收，注册与反注册回调](#pushmessage_receiver_code_setting)\r\n    * [3.4 PushManager接口说明](#pushmanager_interface_describe)\r\n        * [~~3.4.1 旧版Push注册接口~~](#register_description)\r\n        * [~~3.4.2 旧版Push反注册接口~~](#unregister_description)\r\n        * [3.4.3 订阅接口](#register)\r\n        * [3.4.4 反订阅接口](#unregister)\r\n        * [3.4.5 通知栏和透传消息开关状态转换](#pushmessage_switcher)\r\n        * [3.4.6 检查通知栏和透传消息开关状态](#check_switcher)\r\n        * [3.4.7 标签订阅](#subscribe_tags)\r\n        * [3.4.8 取消标签订阅](#un_subscribe_tags)\r\n        * [3.4.9 获取标签订阅列表](#chekc_subscribe_tags)\r\n        * [3.4.10 别名订阅](#subscribe_alias)\r\n        * [3.4.11 取消别名订阅](#un_subscribe_alias)\r\n        * [3.4.12 获取别名](#check_subscribe_alias)\r\n        * [3.4.13 获取pushId](#get_push_id)\r\n  \r\n* [四 通知栏消息扩展功能使用说明](#notification_description)\r\n    * [4.1 打开应用的主界面并获取推送消息参数](#open_mainactivity)\r\n    * [4.2 打开某个应用某个页面时，获取推送消息参数](#open_any_activity)\r\n    * [4.3 参数配置说明](#parameter_setting)\r\n        * [4.3.1 页面名称](#activity_name)\r\n        * [4.3.2 参数与值](#parameter_value)\r\n    * [4.3 打开URI](#open_web)\r\n    * [4.4 自定义通知栏](#set_notification_builder)\r\n\r\n* [反馈与建议](#feedback)\r\n* [问题汇总说明](#question_and_answer)\r\n\r\n## 概述\r\n如果你对pushSDK的实现原理感兴趣，请点击这里 [PushSDK第三方设计实践](http://comsince.github.io/push-design-thirdparty-doc) ，另外这个工程也提供的源码，有兴趣的同学可以star一下！\r\n\r\n## 一 应用背景<a name=\"app_backgroud\"/>\r\n\r\napp为了及时获取到服务器端的消息更新，一般会采用轮寻或者推送的方式来获取消息更新，轮寻导致终端设备流量、电量、等系统资源严重浪费，所以目前采用的比较广泛的是推送的方式，目前 Meizu 的 Push SDK 不能脱离 Flyme OS 存在，当该 SDK 脱离 Flyme OS 之后由于没有长链接导致不能正常收到推送消息。本 SDK 首先要解决的时长链接由 SDK 自己维护，同时还要解决的就是多个 app 引用同一个 SDK 时长链接的复用问题。\r\n\r\n\r\n## 二 设计思想<a name=\"design_thought\"/>\r\n\r\n该 SDK 以 Android Service 方式运行，独占一个进程，该 Service 自己维护与推送服务器的长链接。如果一款手机安装了多个集成了 SDK 的手机应用，则只有一个 service 实例运行，不会每个应用都会开启一个后台 service，而是采用多个应用共享一个Push通道的方式，这就解决了长链接复用的问题，节省了对流量、电量的浪费。使用该 SDK 只需要关心 PushManager 提供的API，与 MzPushMessageReceiver 提供的回调接口以及相应的配置即可。\r\n\r\n\r\n\r\n## 三 魅族云推送集成说明<a name=\"integrete_setting_description\"/>\r\n\r\n\r\n### 准备工作<a name=\"prepare_setting\"/>\r\n\r\nPushSDK3.0以后的版本使用了最新的魅族插件发布aar包，因此大家可以直接引用aar包；无需关心libs so库的配置，对于一些通用的权限配置，工程混淆，应用可以不再配置了，现有你只需要在你的应用中配置相应的消息接收的receiver\r\n\r\n### 3.1 pushSDK内部版引用配置说明<a name=\"pushsdk_internal\"/>\r\n**NOTE:** 请按照项目需求选取用的引用方式引用aar包,第三方开放者需要自行下载pushSDK包,开发这除了要将依赖PushSDK里面的aar,还需配置如下公共开源库\r\n* 对内版本配置如下：\r\n\r\n```\r\n    dependencies {\r\n        compile \"com.android.support:support-v4:22.2.0\"\r\n        compile 'com.android.volley:volley:1.0.0'\r\n        compile 'com.squareup.okhttp:okhttp:2.1.0'\r\n    }\r\n```\r\n\r\n\r\n**NOTE:** 以下内容只是说明push-internal的传递依赖关系,不需要重复配置,实际接入只需要配置上面的就行了\r\n*  工程依赖关系\r\n  PushSDK内部版本aar包托管在meizu的artifactory上,其默认依赖以下库:\r\n  * meizu内部库\r\n    现在Gslb,uxip已经由平台研发部接管，如果你用的旧版本，请以以下版本为准,不要在使用老版本了\r\n    * MzGslb   ```com.meizu.flyme.internet:gslb:3.0.8``` 魅族GSLB组件\r\n    * MzUxip   ```com.meizu.flyme.internet:usage-stats:2.5.1``` 数据统计组件\r\n  * 第三方开源库\r\n    * Volley ```com.android.volley:volley:1.0.0```\r\n    * okHttp ```com.squareup.okhttp:okhttp:2.1.0```\r\n    * support_v4 ```com.android.support:support-v4:22.2.0``` 支持兼容低版本扩展通知栏功能\r\n\r\n**NOTE:** 以下内容说明混淆规则\r\n\r\n*  混淆\r\n  Meizu插件以前是将proguard文件独立发布,因此proguard文件需要独立配置,现在我们已经将proguard打包进了aar中,具体详见[consumerProguardFiles](http://google.github.io/android-gradle-dsl/current/com.android.build.gradle.internal.dsl.BuildType.html#com.android.build.gradle.internal.dsl.BuildType:consumerProguardFiles),因此就不再需要单独配置proguard远程依赖了\r\n\r\n### 3.2 pushSDK外部版引用配置说明<a name=\"pushsdk_open\"/>\r\n\r\n**NOTE:** 如果是魅族内部应用请跳过此配置,如果应用需要支持第三方推送的可以进行以下配置,对外版本的SDK主要是在第三方Android Rom中实现推送功能,其默依赖pushSDK内部版,目前暂未开放\r\n\r\n\r\n\r\n### 3.3 必要的配置<a name=\"nessary_setting\"/>\r\n\r\n### 3.3.1 兼容flyme5以下版本推送兼容配置<a name=\"permission_adpter_flyme5_down\"/>\r\n\r\n```\r\n    <!-- 兼容flyme5.0以下版本，魅族内部集成pushSDK必填，不然无法收到消息-->\r\n    <uses-permission android:name=\"com.meizu.flyme.push.permission.RECEIVE\"></uses-permission>\r\n    <permission android:name=\"包名.push.permission.MESSAGE\" android:protectionLevel=\"signature\"/>\r\n    <uses-permission android:name=\"包名.push.permission.MESSAGE\"></uses-permission>\r\n    \r\n    <!--  兼容flyme3.0配置权限-->\r\n    <uses-permission android:name=\"com.meizu.c2dm.permission.RECEIVE\" />\r\n    <permission android:name=\"你的包名.permission.C2D_MESSAGE\"\r\n                    android:protectionLevel=\"signature\"></permission>\r\n    <uses-permission android:name=\"你的包名.permission.C2D_MESSAGE\"/>\r\n\r\n```\r\n\r\n#### 3.3.2 注册消息接收Receiver<a name=\"pushmessage_receiver_manifest_setting\"/>\r\n\r\n```xml\r\n    <!-- push应用定义消息receiver声明 -->\r\n    <receiver android:name=\"your.package.MyPushMsgReceiver\">\r\n        <intent-filter>\r\n            <!-- 接收push消息 -->\r\n            <action android:name=\"com.meizu.flyme.push.intent.MESSAGE\" />\r\n            <!-- 接收register消息 -->\r\n            <action android:name=\"com.meizu.flyme.push.intent.REGISTER.FEEDBACK\" />\r\n            <!-- 接收unregister消息-->\r\n            <action android:name=\"com.meizu.flyme.push.intent.UNREGISTER.FEEDBACK\"/>\r\n            <!-- 兼容低版本Flyme3推送服务配置 -->\r\n            <action android:name=\"com.meizu.c2dm.intent.REGISTRATION\" />\r\n            <action android:name=\"com.meizu.c2dm.intent.RECEIVE\" />\r\n            <category android:name=\"包名\"></category>\r\n        </intent-filter>\r\n    </receiver>\r\n```\r\n#### 3.3.3 实现自有的PushReceiver,实现消息接收，注册与反注册回调<a name=\"pushmessage_receiver_code_setting\"/>\r\n\r\n```\r\n\tpublic class MyPushMsgReceiver extends MzPushMessageReceiver {\r\n    \r\n    \t    @Override\r\n    \t    @Deprecated\r\n    \t    public void onRegister(Context context, String pushid) {\r\n    \t\t   //应用在接受返回的pushid\r\n    \t    }\r\n    \r\n    \t    @Override\r\n    \t    public void onMessage(Context context, String s) {\r\n    \t\t//接收服务器推送的消息\r\n    \t    }\r\n    \r\n    \t    @Override\r\n    \t    @Deprecated\r\n    \t    public void onUnRegister(Context context, boolean b) {\r\n    \t\t//调用PushManager.unRegister(context）方法后，会在此回调反注册状态\r\n    \t    }\r\n    \r\n    \t    //设置通知栏小图标\r\n    \t    @Override\r\n    \t    public PushNotificationBuilder onUpdateNotificationBuilder(PushNotificationBuilder pushNotificationBuilder) {\r\n    \t\tpushNotificationBuilder.setmStatusbarIcon(R.drawable.mz_stat_share_weibo);\r\n    \t    }\r\n    \r\n    \t    @Override\r\n    \t    public void onPushStatus(Context context,PushSwitchStatus pushSwitchStatus) {\r\n    \t\t//检查通知栏和透传消息开关状态回调\r\n    \t    }\r\n    \r\n    \t    @Override\r\n    \t    public void onRegisterStatus(Context context,RegisterStatus registerStatus) {\r\n    \t\t   Log.i(TAG, \"onRegisterStatus \" + registerStatus);\r\n                    //新版订阅回调\r\n    \t    }\r\n    \r\n    \t    @Override\r\n    \t    public void onUnRegisterStatus(Context context,UnRegisterStatus unRegisterStatus) {\r\n    \t\t  Log.i(TAG,\"onUnRegisterStatus \"+unRegisterStatus);\r\n                    //新版反订阅回调\r\n    \t    }\r\n    \r\n    \t    @Override\r\n    \t    public void onSubTagsStatus(Context context,SubTagsStatus subTagsStatus) {\r\n    \t\t   Log.i(TAG, \"onSubTagsStatus \" + subTagsStatus);\r\n    \t\t//标签回调\r\n    \t    }\r\n    \r\n    \t    @Override\r\n    \t    public void onSubAliasStatus(Context context,SubAliasStatus subAliasStatus) {\r\n    \t\t   Log.i(TAG, \"onSubAliasStatus \" + subAliasStatus);\r\n                    //别名回调\r\n    \t    }\r\n    \t    @Override\r\n            public void onNotificationArrived(Context context, String title, String content, String selfDefineContentString) {\r\n                DebugLogger.i(TAG,\"onNotificationArrived title \"+title + \"content \"+content + \" selfDefineContentString \"+selfDefineContentString);\r\n            }\r\n        \r\n            @Override\r\n            public void onNotificationClicked(Context context, String title, String content, String selfDefineContentString) {\r\n                DebugLogger.i(TAG,\"onNotificationClicked title \"+title + \"content \"+content + \" selfDefineContentString \"+selfDefineContentString);\r\n            }\r\n        \r\n            @Override\r\n            public void onNotificationDeleted(Context context, String title, String content, String selfDefineContentString) {\r\n                DebugLogger.i(TAG,\"onNotificationDeleted title \"+title + \"content \"+content + \" selfDefineContentString \"+selfDefineContentString);\r\n            }    \r\n   \r\n    \t}\r\n```\r\n\r\n**Note:** 至此pushSDK 已经集成完毕，现在你需要在你的Application中调用新版的[register](#register)方法,并在你的Receiver中成功回调onRegisterStatus(RegisterStatus registerStatus)方法就可以了，\r\n你现在可以到[新版Push平台](http://push.meizu.com) 找到你的应用推送消息就可以了;以下内容是pushSDK提供的api汇总,具体功能详见api具体说明,请根据需求选用合适的功能\r\n\r\n### 3.4 PushManager接口说明<a name=\"pushmanager_interface_describe\"/>\r\n#### 3.4.1 ~~旧版订阅接口~~<a name=\"register_description\"/>\r\n```\r\n    /**\r\n      * 订阅接口\r\n      */\r\n    public static void register(Context context);\r\n```\r\n\r\n**NOTE:** 此接口已经废弃建议使用新版的订阅接口\r\n* 说明：原则上应用调用register方法表示与服务器建立推送关系，这是可以通过push平台向该应用推送消息了，所以应用至少要调用过一次register方法,应用为了防止多次重复注册，可以先判断一下是否获取成功过pushid，具体实现代码如下：\r\n\r\n```java\r\n\tif(PushManager.getPushId(context) == null){\r\n\t   PushManager.register(Context context)\r\n\t}\r\n\r\n```\r\n\r\n**Note:**\r\n   * (1)如果应用需要取消订阅,调用如下方法 PushManager.unRegister(Context context)\r\n   * (2)应用如果成功获取到pushId,可以调用一下方法获取本应用的pushId PushManager.getPushId(Context context)\r\n\r\n#### 3.4.2 ~~旧版反订阅接口~~<a name=\"unregister_description\"/>\r\n**NOTE:** 此接口已经废弃\r\n```\r\n    /**\r\n      * 反订阅\r\n      * */\r\n    public static void unRegister(Context context);\r\n```\r\n\r\n**NOTE:** 以下为新版的接口,所有的接口对应的回调都你的配置的PushReceiver中\r\n#### 3.4.3 订阅接口<a name=\"register\"/>\r\n* 接口说明\r\n\r\n```\r\n   /**\r\n     * @param context\r\n     * @param appId\r\n     *         push 平台申请的应用id\r\n     * @param appKey\r\n     *         push 平台申请的应用key\r\n     * */\r\n     public static void register(Context context,String appId,String appKey);\r\n```\r\n\r\n* 对应Receiver中的回调方法\r\n\r\n```\r\n    @Override\r\n    public void onRegisterStatus(Context context,RegisterStatus registerStatus) {\r\n        \r\n    }\r\n```\r\n\r\n#### 3.4.4 反订阅接口<a name=\"unregister\"/>\r\n* 接口说明\r\n\r\n```\r\n   /**\r\n     * @param context\r\n     * @param appId\r\n     *         push 平台申请的应用id\r\n     * @param appKey\r\n     *         push 平台申请的应用key\r\n     * */\r\n     public static void unRegister(Context context,String appId,String appKey);\r\n```\r\n\r\n* 对应Receiver中的回调方法\r\n\r\n```\r\n    @Override\r\n    public void onUnRegisterStatus(Context context,UnRegisterStatus unRegisterStatus) {\r\n        \r\n    }\r\n```\r\n\r\n#### 3.4.5 通知栏和透传消息开关状态转换<a name=\"pushmessage_switcher\"/>\r\n* 接口说明\r\n\r\n```\r\n   /**\r\n     * @param appId\r\n     *        push 平台申请的应用id\r\n     * @param appKey\r\n     *        push 平台申请的应用key\r\n     * @param pushId\r\n     *        注册成功后返回的pushid\r\n     * @param pushType\r\n     *        接收的消息类型，0:通知栏消息 1: 透传消息\r\n     * @param switcher\r\n     *        修改push类型开关状态\r\n     * */\r\n    public static void switchPush(Context context,String appId,String appKey,String pushId,int pushType,boolean switcher);\r\n```\r\n\r\n* 对应Receiver中的回调方法\r\n\r\n```\r\n    @Override\r\n    public void onPushStatus(Context context,PushSwitchStatus pushSwitchStatus) {\r\n        \r\n    }\r\n```\r\n\r\n#### 3.4.6 检查通知栏和透传消息开关状态<a name=\"check_switcher\"/>\r\n* 接口说明\r\n\r\n```\r\n   /**\r\n     * 检查通知栏和透传消息开关状态\r\n     * @param appId\r\n     *          push 平台申请的应用id\r\n     * @param appKey\r\n     *          push 平台申请的应用key\r\n     * @param pushId\r\n     *          注册成功后返回的pushid\r\n     *\r\n     *  结果会在你所实现的receiver的onCheckPush中返回\r\n     * */\r\n    public static void checkPush(Context context,String appId,String appKey,String pushId);\r\n```\r\n\r\n* 对应Receiver中的回调方法\r\n\r\n```\r\n    @Override\r\n    public void onPushStatus(Context context,PushSwitchStatus pushSwitchStatus) {\r\n        \r\n    }\r\n```\r\n\r\n#### 3.4.7 标签订阅<a name=\"subscribe_tags\"/>\r\n* 接口说明\r\n\r\n```\r\n   /**\r\n     * 标签订阅\r\n     * @param context\r\n     * @param appId\r\n     *         push 平台申请的应用id\r\n     * @param appKey\r\n     *         push 平台申请的应用key\r\n     * @param tags\r\n     *         多个标签逗号隔离\r\n     * */\r\n     public static void subScribeTags(Context context,String appId,String appKey,String pushId,String tags);\r\n```\r\n\r\n* 对应Receiver中的回调方法\r\n\r\n```\r\n      @Override\r\n      public void onSubTagsStatus(Context context,SubTagsStatus subTagsStatus) {\r\n        Log.i(TAG, \"onSubTagsStatus \" + subTagsStatus);\r\n        //标签回调\r\n      }\r\n```\r\n\r\n#### 3.4.8 取消标签订阅<a name=\"un_subscribe_tags\"/>\r\n* 接口说明\r\n\r\n```\r\n    /**\r\n      * 取消标签订阅\r\n      * @param context\r\n      * @param appId\r\n      *         push 平台申请的应用id\r\n      * @param appKey\r\n      *         push 平台申请的应用key\r\n      * @param tags\r\n      *         多个标签逗号隔离\r\n      * */\r\n     public static void unSubScribeTags(Context context, String appId, String appKey, String pushId,String tags);\r\n```\r\n\r\n* 对应Receiver中的回调方法\r\n\r\n```\r\n      @Override\r\n      public void onSubTagsStatus(Context context,SubTagsStatus subTagsStatus) {\r\n        Log.i(TAG, \"onSubTagsStatus \" + subTagsStatus);\r\n        //标签回调\r\n      }\r\n```\r\n\r\n#### 3.4.9 获取标签订阅列表<a name=\"chekc_subscribe_tags\"/>\r\n* 接口说明\r\n\r\n```\r\n   /**\r\n     * 获取标签订阅列表\r\n     * @param context\r\n     * @param appId\r\n     *         push 平台申请的应用id\r\n     * @param appKey\r\n     *         push 平台申请的应用key\r\n     * */\r\n     public static void checkSubScribeTags(Context context,String appId,String appKey,String pushId);\r\n```\r\n\r\n* 对应Receiver中的回调方法\r\n\r\n```\r\n      @Override\r\n      public void onSubTagsStatus(Context context,SubTagsStatus subTagsStatus) {\r\n        Log.i(TAG, \"onSubTagsStatus \" + subTagsStatus);\r\n        //标签回调\r\n      }\r\n```\r\n\r\n#### 3.4.10 别名订阅<a name=\"subscribe_alias\"/>\r\n* 接口说明\r\n\r\n```\r\n   /**\r\n     * 别名订阅\r\n     * @param context\r\n     * @param appId\r\n     *         push 平台申请的应用id\r\n     * @param appKey\r\n     *         push 平台申请的应用key\r\n     * @param pushId\r\n     *         注册成功后返回的pushid\r\n     * @param alias\r\n     *         别名\r\n     * */\r\n     public static void subScribeAlias(Context context,String appId,String appKey,String pushId,String alias);\r\n```\r\n\r\n* 对应Receiver中的回调方法\r\n\r\n```\r\n    @Override\r\n    public void onSubAliasStatus(Context context,SubAliasStatus subAliasStatus) {\r\n        Log.i(TAG, \"onSubAliasStatus \" + subAliasStatus);\r\n    }\r\n```\r\n\r\n#### 3.4.11 取消别名订阅<a name=\"un_subscribe_alias\"/>\r\n* 接口说明\r\n\r\n```\r\n   /**\r\n     * 取消别名订阅\r\n     * @param context\r\n     * @param appId\r\n     *         push 平台申请的应用id\r\n     * @param appKey\r\n     *         push 平台申请的应用key\r\n     * @param pushId\r\n     *         注册成功后返回的pushid\r\n     * @param alias\r\n     *         别名\r\n     * */\r\n     public static void unSubScribeAlias(Context context,String appId,String appKey,String pushId,String alias);\r\n```\r\n\r\n* 对应Receiver中的回调方法\r\n\r\n```\r\n    @Override\r\n    public void onSubAliasStatus(Context context,SubAliasStatus subAliasStatus) {\r\n        Log.i(TAG, \"onSubAliasStatus \" + subAliasStatus);\r\n    }\r\n```\r\n\r\n#### 3.4.12 获取别名<a name=\"check_subscribe_alias\"/>\r\n* 接口说明\r\n\r\n```\r\n   /**\r\n     * 获取别名\r\n     * @param context\r\n     * @param appId\r\n     *         push 平台申请的应用id\r\n     * @param appKey\r\n     *         push 平台申请的应用key\r\n     * @param pushId\r\n     *         注册成功后返回的pushid\r\n     * */\r\n     public static void checkSubScribeAlias(Context context,String appId,String appKey,String pushId)\r\n```\r\n\r\n* 对应Receiver中的回调方法\r\n\r\n```\r\n    @Override\r\n    public void onSubAliasStatus(Context context,SubAliasStatus subAliasStatus) {\r\n        Log.i(TAG, \"onSubAliasStatus \" + subAliasStatus);\r\n    }\r\n```\r\n\r\n#### 3.4.13 获取pushId<a name=\"get_push_id\"/>\r\n* 接口说明\r\n\r\n```\r\n   /**\r\n     * 根据应用包名获取pushId\r\n     * @param context\r\n     * @return 如果该包名没有注册，则默认返回为null\r\n     * */\r\n    public static String getPushId(Context context);\r\n```\r\n\r\n\r\n## 四 通知栏消息扩展功能使用说明<a name=\"notification_description\"/>\r\n\r\n### 4.1 打开应用的主界面并获取推送消息参数<a name=\"open_mainactivity\"/>\r\n\r\n在push平台选择打开应用主界面，推送完消息后，手机端收到通知栏消息，应用点击通知栏会跳转到应用的主界面 ，此时你在push平台配置的参数与值将通过intent传递给你，你可以通过以下代码获取值\r\n\r\n```\r\n String value = getIntent().getStringExtra(\"key\")\r\n 通过在push平台上配置的参数，获取其value值,这里的key值就是你在push平台上配置的键值\r\n```\r\n\r\n### 4.2 打开某个应用某个页面时，获取推送消息参数<a name=\"open_any_activity\"/>\r\n\r\n打开应用某个页面，实际通过你在push平台配置的页面名称，参数key-value组建intent的方式传递给应用\r\n如下是通过应用包名+activity名称+参数组建Intent的部分代码：\r\n\r\n```\r\n  String intentUri = \"intent:#Intent;component=\"+应用包名+\"/\"+AndroidManifest配置activity的名称+(TextUtils.isEmpty(key) ? \";\" : \";\"+Value)+\"end\";\r\n  try {\r\n     intent = Intent.parseUri(intentUri,Intent.URI_INTENT_SCHEME);\r\n  } catch (URISyntaxException e) {\r\n     e.printStackTrace();\r\n  }\r\n```\r\n\r\n### 4.3参数配置说明<a name=\"parameter_setting\"/>\r\n#### 4.3.1 页面名称<a name=\"activity_name\"/>\r\nPush平台中页面名称实际为：应用要打开的Activity名称,即是相对应用的包名的Activity名称，如下一段配置\r\n```\r\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    package=\"你的包名\">\r\n    <application\r\n        android:allowBackup=\"true\"\r\n        android:icon=\"@drawable/ic_launcher\"\r\n        android:label=\"@string/app_name\"\r\n        android:theme=\"@style/AppTheme\" >\r\n        <activity android:name=\".TestAcitivity\">\r\n        </activity>\r\n    </application>\r\n </manifest>\r\n```\r\n\r\n比如你要打开应用下面的TestActivity这个页面，Push平台页面这个选项就填写.TestAcitivity,pushSDK就会根据这个名称组建该页面的完整路径：应用包名.TestAcitivity;这样当你点击通知栏时就会打开你配置的页面了。\r\n\r\n> **Note:** 更为简洁的做法是将该activity的全路径全部写出来如下：（com.meizu.cloud.setting.loginAcitivity）\r\n\r\n#### 4.3.2 参数与值<a name=\"parameter_value\"/>\r\n在push平台上配置的参数，是以key-value的方式传递给pushSDK,当pushSDK收到通知后会组建参数通过Intent传递给应用的相关界面, 应用可通过下面的方法逐一获取相应的value值\r\n```\r\nString value = getIntent().getStringExtra(\"push平台配置的键值\")\r\n通过在push平台上配置的参数，获取其value值,这里的key值就是你在push平台上配置的键值\r\n```\r\n\r\n### 4.3 打开网页<a name=\"open_web\"/>\r\n\r\n当你push平台选取了打开网页这个选项，并配置的网页地址，当pushSDK收到消息后就会弹出通知栏，当你点击后会跳转到你设置的默认的浏览器显示当前的网页\r\n\r\n### 4.4 自定义通知栏<a name=\"set_notification_builder\"/>\r\n\r\nPushSDK加入了通知栏状态栏小图标自定义的功能，需要在配置的的pushReceiver中覆盖如下的方法：\r\n\r\n```\r\n    /**\r\n     * 获取smallicon\r\n     * */\r\n    public void onUpdateNotificationBuilder(PushNotificationBuilder pushNotificationBuilder){\r\n          //设置通知栏弹出的小图标\r\n          pushNotificationBuilder.setmStatusbarIcon(R.drawalbe.icon);\r\n    };\r\n```\r\n\r\n> **Note:** 通知栏相关操作API都封装在PushNotificationBuilder 中，更多功能参见此类中的方法\r\n\r\n## 五 兼容Flyme低版本推送\r\n### 5.1兼容说明\r\n云服务经历几次大的变更，从之前的C2DM，到现在可以完全脱离Flyme平台作为一种完全开放给第三方应用的SDK，在这个阶段出现多种集成方式，给以后的应用集成带来极大的困扰，魅族PushSDK极力在减少Flyme版本迭代给应用集成带来的麻烦，但应用还是需要做细小的更改才能做到与低版本Flyme的兼容。\r\n### 5.2 兼容Flyme3.0等低版本推送服务\r\n#### 5.2.1 增加权限声明配置\r\n```\r\n <uses-permission android:name=\"com.meizu.c2dm.permission.RECEIVE\" />\r\n <permission android:name=\"你的应用包名.permission.C2D_MESSAGE\"\r\n             android:protectionLevel=\"signature\"></permission>\r\n <uses-permission android:name=\"你的应用包名.permission.C2D_MESSAGE\"/>\r\n```\r\n#### 5.2.2 增加PushReceiver Action声明\r\n```\r\n  <action android:name=\"com.meizu.c2dm.intent.REGISTRATION\" />\r\n  <action android:name=\"com.meizu.c2dm.intent.RECEIVE\" />\r\n```\r\n\r\n一个完整的兼容Flyme3.0 推送的Receiver配置如下:\r\n```\r\n<!-- push应用定义消息receiver声明 -->\r\n<receiver android:name=\"your.package.PushMsgReceiver\">\r\n     <intent-filter>\r\n     <!-- 接收push消息 -->\r\n     <action android:name=\"com.meizu.flyme.push.intent.MESSAGE\" />\r\n     <!-- 接收register消息-->\r\n     <action android:name=\"com.meizu.flyme.push.intent.REGISTER.FEEDBACK\"/>\r\n     <!-- 接收unregister消息-->\r\n     <action android:name=\"com.meizu.flyme.push.intent.UNREGISTER.FEEDBACK\"/>\r\n     <!-- 兼容低版本Flyme推送服务配置 -->\r\n     <action android:name=\"com.meizu.c2dm.intent.REGISTRATION\" />\r\n     <action android:name=\"com.meizu.c2dm.intent.RECEIVE\" />\r\n     <category android:name=\"你的应用包名\"></category>\r\n     </intent-filter>\r\n </receiver>\r\n```\r\n#### 5.2.3 实现onMessage接收推送消息\r\nPushMessageReceiver覆盖onMessage(Context context,Intent intent)方法接收Flyme3.0平台push消息\r\n\r\n详情参见下面的方法的说明:\r\n```\r\n /**\r\n   * 收到推送消息的回调,Flyme4.0以上版本,或者云服务5.0以上版本 通过此方法接收Push消息\r\n   * @param context\r\n   *            context\r\n   * @param message\r\n   *            收到的推送消息\r\n   * */\r\n   public abstract void onMessage(Context context,String message);\r\n\r\n   /**\r\n   * 处理flyme3.0等以下平台的推送消息\r\n   * @param context\r\n   * @param intent\r\n   *           flyme3.0平台上默认是将透传的消息json,按照key-value的组合设置到intent中,如果要获取相应的数据,可以调用intent.getExtra(key)方法获取\r\n   * */\r\n   public void onMessage(Context context,Intent intent){}\r\n```\r\n\r\n#### 5.2.4 消息接入流程\r\n注意这里的onMessage方法参数不一样,应用接收到消息后，需要自己从Intent中自行获取推送的消息,完整的流程如下\r\n\r\n* (1) 调用Push接口接口发送消息时,消息体为一个正确Json字符串，例如：\r\n```\r\n{\r\n       \"content\": \"今日头像下载app狂送100元\",\r\n       \"title\": \"今日头条重大利好\",\r\n       \"isDiscard\": true,\r\n       \"clickType\": \"1\"\r\n }\r\n```\r\n* (2) 处理推送消息\r\n   例如应用需要获取content字段的内容,可以通过intent获取相应的内容，完成代码如下\r\n```\r\n    @Override\r\n    public void onMessage(Context context, Intent intent) {\r\n       String content = intent.getStringExtra(\"content\");\r\n       Log.i(TAG,\"flyme3 onMessage \"+content);\r\n    }\r\n```\r\n\r\n\r\n\r\n### 反馈与建议\r\n\r\n\r\n### 问题汇总说明\r\n*  1.Push服务收到推送消息，但是应用不弹出通知栏\r\n   应用如果正确接入PushSDK，且能收到pushID表明Push服务与应用连接正常，有可能是应用没有配置混淆，导致MzPushSDK被混淆，无法正确解析消息所致\r\n\r\n#### 一. 配置类问题\r\n\r\n* 现象\r\n```\r\n    android.content.ActivityNotFoundException: Unable to find explicit activity class\r\n    {com.meizu.mzbbs/com.meizu.mzbbs.ui.DetailsActivity }; \r\n    have you declared this activity in your AndroidManifest.xml?\r\n``` \r\n\r\n* 原因\r\n平台配置出现空格等特殊字符\r\nactivity配置出错\r\n\r\n#### 二. 网络问题\r\n* 现象\r\n接收不到推送\r\n* 解决方案\r\n请先确认你所连接的网络是外网还是内网，你可以清除云服务的数据，重新发起注册\r\n\r\n#### 三 魅族手机未发布问题\r\n* 现象\r\n注册成功，收不到推送\r\n* 原因分析\r\n未发布的手机由于Brand字段不为meizu，导致注册的时候push任务手机为第三方手机，其采用的就是imei_sn的方式注册，返回的pushID即为imei_sn_appID\r\n\r\n* 解决方案\r\n等待发布Brand更改为魅族，或者直接使用imei_sn的推送方式\r\n\r\n#### 四 日志分析\r\n* 日志地址\r\n```\r\n/sdcard/Android/data/pushSdk\r\n```\r\n\r\n#### 五 aar引用问题\r\n* 出现aar最新包不生效，删除gradle cache即可\r\n```\r\n    删除volley-gslb兼容包aar本地缓存，其他请求可自行选择目录删除\r\n    rm -rf ~/.gradle/caches/modules-2/files-2.1/com.meizu.gslb.volley\r\n```\r\n\r\n#### 六 push服务收到推送但是应用无法收到消息\r\n* 现象\r\n  在熄屏状态下应用无法收到通知栏消息，亮屏时能收到通知栏消息,最新的flyme固件不会出现该问题\r\n* 原因\r\n  系统问题，熄屏状态下发起服务调用，应用无响应,最新的flyme固件不会出现该问题\r\n\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}